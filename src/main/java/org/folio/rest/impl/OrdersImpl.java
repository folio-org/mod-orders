package org.folio.rest.impl;

import io.vertx.core.AsyncResult;
import io.vertx.core.Context;
import io.vertx.core.Future;
import io.vertx.core.Handler;
import io.vertx.core.http.HttpHeaders;
import io.vertx.core.json.JsonObject;
import io.vertx.core.logging.Logger;
import io.vertx.core.logging.LoggerFactory;
import org.apache.commons.lang3.StringUtils;
import org.folio.orders.rest.exceptions.HttpException;
import org.folio.rest.annotations.Validate;
import org.folio.rest.jaxrs.model.CompositePurchaseOrder;
import org.folio.rest.jaxrs.model.PoLine;
import org.folio.rest.jaxrs.resource.Orders;
import org.folio.rest.tools.client.HttpClientFactory;
import org.folio.rest.tools.client.interfaces.HttpClientInterface;
import org.folio.rest.tools.utils.TenantTool;

import javax.ws.rs.core.Response;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletionException;

import static org.folio.orders.utils.HelperUtils.DEFAULT_POLINE_LIMIT;
import static org.folio.orders.utils.HelperUtils.GET_ALL_POLINES_QUERY_WITH_LIMIT;
import static org.folio.orders.utils.HelperUtils.PO_LINES_LIMIT_PROPERTY;
import static org.folio.orders.utils.HelperUtils.getProperty;
import static org.folio.orders.utils.HelperUtils.handleGetRequest;
import static org.folio.orders.utils.HelperUtils.loadConfiguration;
import static org.folio.rest.RestVerticle.OKAPI_HEADER_TENANT;

public class OrdersImpl implements Orders {

  private static final Logger logger = LoggerFactory.getLogger(OrdersImpl.class);

  public static final String OKAPI_HEADER_URL = "X-Okapi-Url";
  private static final String ORDERS_LOCATION_PREFIX = "/orders/";
  private static final String ORDER_LINE_LOCATION_PREFIX = "/orders/%s/lines/%s";
  public static final String OVER_LIMIT_ERROR_MESSAGE = "Your FOLIO system is configured to limit the number of PO Lines on each order to %s.";
  public static final String MISMATCH_BETWEEN_ID_IN_PATH_AND_PO_LINE = "Mismatch between id in path and PoLine";

  @Override
  @Validate
  public void deleteOrdersById(String id, String lang, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);

    //to handle delete API's content-type text/plain
    Map<String,String> customHeader=new HashMap<>();
    customHeader.put(HttpHeaders.ACCEPT.toString(), "application/json, text/plain");
    httpClient.setDefaultHeaders(customHeader);

    DeleteOrdersByIdHelper helper = new DeleteOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);
    helper.deleteOrder(id,lang)
    .thenRun(()->{
      logger.info("Successfully deleted order: ");
      httpClient.closeClient();
      javax.ws.rs.core.Response response = DeleteOrdersByIdResponse.respond204();
      AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
      asyncResultHandler.handle(result);
    })
    .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void getOrdersById(String id, String lang, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    GetOrdersByIdHelper helper = new GetOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    helper.getOrder(id, lang)
      .thenAccept(order -> {
        logger.info("Successfully retrieved order: " + JsonObject.mapFrom(order).encodePrettily());
        httpClient.closeClient();
        javax.ws.rs.core.Response response = GetOrdersByIdResponse.respond200WithApplicationJson(order);
        AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
        asyncResultHandler.handle(result);
      })
      .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void postOrders(String lang, CompositePurchaseOrder compPO, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    PostOrdersHelper helper = new PostOrdersHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);
    loadConfiguration(okapiHeaders, vertxContext, logger).thenRun(() -> {
      int limit = getPoLineLimit(okapiHeaders);
      if (compPO.getPoLines().size() <= limit) {
        logger.info("Creating PO and POLines...");
        helper.createPOandPOLinesWithAutoGeneratedData(compPO)
          .thenAccept(withIds -> {

            logger.info("Applying Funds...");
            helper.applyFunds(withIds)
              .thenAccept(withFunds -> {

                logger.info("Updating Inventory...");
                helper.updateInventory(withFunds)
                  .thenAccept(withInventory -> {

                    logger.info("Successfully Placed Order: " + JsonObject.mapFrom(withInventory).encodePrettily());
                    httpClient.closeClient();
                    javax.ws.rs.core.Response response = PostOrdersResponse.respond201WithApplicationJson(withInventory,
                      PostOrdersResponse.headersFor201().withLocation(ORDERS_LOCATION_PREFIX + withInventory.getId()));
                    AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
                    asyncResultHandler.handle(result);
                  })
                  .exceptionally(helper::handleError);
              })
              .exceptionally(helper::handleError);
          })
          .exceptionally(helper::handleError);
      } else {
       helper.handleError(new Exception(new HttpException(422, String.format(OVER_LIMIT_ERROR_MESSAGE, limit))));
      }
    }).exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void putOrdersById(String id, String lang, CompositePurchaseOrder compPO, Map<String, String> okapiHeaders,
      Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    PutOrdersByIdHelper putHelper = new PutOrdersByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);
    putHelper.updateOrder(id, lang, compPO, vertxContext)
       .exceptionally(putHelper::handleError);

  }

  @Override
  @Validate
  public void postOrdersLinesById(String orderId, String lang, PoLine poLine, Map<String, String> okapiHeaders,
                                  Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    PostOrderLineHelper helper = new PostOrderLineHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    logger.info("Creating POLine to an existing order...");

    if (poLine.getPurchaseOrderId() == null) {
      logger.info("POLine without id. Set id from path url: " + orderId);
      poLine.setPurchaseOrderId(orderId);
    }
    loadConfiguration(okapiHeaders, vertxContext, logger).thenRun(() -> {
      if (orderId.equals(poLine.getPurchaseOrderId())) {
        String endpoint = String.format(GET_ALL_POLINES_QUERY_WITH_LIMIT, 1, orderId, lang);
        handleGetRequest(endpoint, httpClient, vertxContext, okapiHeaders, logger)
          .thenAccept(entries -> {
            int limit = getPoLineLimit(okapiHeaders);
            if (entries.getInteger("total_records") < limit) {
              helper.createPoLine(poLine)
                .thenAccept(pol -> {
                  logger.info("Successfully added PO Line: " + JsonObject.mapFrom(pol).encodePrettily());
                  httpClient.closeClient();
                  Response response = PostOrdersLinesByIdResponse.respond201WithApplicationJson
                    (poLine, PostOrdersLinesByIdResponse.headersFor201().withLocation(String.format(ORDER_LINE_LOCATION_PREFIX, orderId, pol.getId())));
                  AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
                  asyncResultHandler.handle(result);
                })
                .exceptionally(helper::handleError);
            } else {
              asyncResultHandler.handle(Future.succeededFuture(helper.buildErrorResponse(422, String.format(OVER_LIMIT_ERROR_MESSAGE, limit))));
            }
          }).exceptionally(helper::handleError);
      } else {
        asyncResultHandler
          .handle(Future.succeededFuture(helper.buildErrorResponse(400, MISMATCH_BETWEEN_ID_IN_PATH_AND_PO_LINE)));
      }
    }).exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void getOrdersLinesByIdAndLineId(String id, String lineId, String lang, Map<String, String> okapiHeaders,
                                          Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {

    logger.info("Started Invocation of POLine Request with id = " + lineId);
    final HttpClientInterface httpClient = getHttpClient(okapiHeaders);
    GetPOLineByIdHelper helper = new GetPOLineByIdHelper(httpClient, okapiHeaders, asyncResultHandler, vertxContext);

    helper.getPOLineByPOLineId(id, lineId, lang)
      .thenAccept(poline -> {
        logger.info("Received POLine Response: " + JsonObject.mapFrom(poline).encodePrettily());
        httpClient.closeClient();
        javax.ws.rs.core.Response response = GetOrdersLinesByIdAndLineIdResponse.respond200WithApplicationJson(poline);
        AsyncResult<javax.ws.rs.core.Response> result = Future.succeededFuture(response);
        asyncResultHandler.handle(result);
      })
      .exceptionally(helper::handleError);
  }

  @Override
  @Validate
  public void deleteOrdersLinesByIdAndLineId(String orderId, String lineId, String lang, Map<String, String> okapiHeaders,
                                             Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    new DeleteOrderLineByIdHelper(okapiHeaders, asyncResultHandler, vertxContext)
      .deleteLine(orderId, lineId, lang);
  }

  @Override
  @Validate
  public void putOrdersLinesByIdAndLineId(String orderId, String lineId, String lang, PoLine poLine, Map<String, String> okapiHeaders,
                                            Handler<AsyncResult<javax.ws.rs.core.Response>> asyncResultHandler, Context vertxContext) {
    logger.info("Handling PUT Order Line operation...");

    PutOrderLineByIdHelper helper = new PutOrderLineByIdHelper(okapiHeaders, asyncResultHandler, vertxContext);
    if (StringUtils.isEmpty(poLine.getPurchaseOrderId())) {
      poLine.setPurchaseOrderId(orderId);
    }
    if (StringUtils.isEmpty(poLine.getId())) {
      poLine.setId(lineId);
    }
    if (orderId.equals(poLine.getPurchaseOrderId()) && lineId.equals(poLine.getId())) {
      helper
        .updateOrder(orderId, lang, poLine);
    } else {
      asyncResultHandler
        .handle(Future.succeededFuture(helper.buildErrorResponse(422, MISMATCH_BETWEEN_ID_IN_PATH_AND_PO_LINE)));
    }
  }

  public static HttpClientInterface getHttpClient(Map<String, String> okapiHeaders) {
    final String okapiURL = okapiHeaders.getOrDefault(OKAPI_HEADER_URL, "");
    final String tenantId = TenantTool.calculateTenantId(okapiHeaders.get(OKAPI_HEADER_TENANT));

    return HttpClientFactory.getHttpClient(okapiURL, tenantId);
  }

  private static int getPoLineLimit(Map<String, String> okapiHeaders) {
    try {
      String tenant = okapiHeaders.get(OKAPI_HEADER_TENANT);
      return Integer.parseInt(getProperty(tenant, PO_LINES_LIMIT_PROPERTY, DEFAULT_POLINE_LIMIT));
    } catch (NumberFormatException e) {
      throw new CompletionException("Invalid limit value in configuration.", e);
    }
  }

}

